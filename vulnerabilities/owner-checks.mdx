---
title: "Missing Owner Checks"
description: "Learn how missing ownership validation lets attackers substitute fake accounts into your Solana program -- and how to fix it"
icon: "user-shield"
---

Every Solana account carries an `owner` field that the runtime sets. When a program deserializes an account without checking that field, an attacker can craft a lookalike account, fill it with malicious data, and pass it right through.

## What we will build

In this tutorial we will:

- Write a vulnerable Anchor program that accepts any account via `UncheckedAccount`, then exploit it with a fake account containing attacker-controlled data
- Write the equivalent vulnerable Pinocchio program that omits the `owned_by()` guard, and demonstrate the same attack
- Apply the one-line fix in each framework and confirm the attack no longer works

<Note>
**Prerequisites.** Clone the repository, install dependencies, and build once before starting:

```bash
git clone https://github.com/danielAsaboro/solana_badger.git
cd solana_badger
npm install
anchor build
```
</Note>

## Step 1 -- Define the account state (Anchor)

We start with a simple account that stores a `u64` data field and an `authority` pubkey. Both the vulnerable and secure Anchor programs share this state definition.

```rust filename="programs/owner-checks/vulnerable/anchor/src/state.rs"
use anchor_lang::prelude::*;

#[account]
pub struct ProgramAccount {
    pub data: u64,
    pub authority: Pubkey,
}

impl ProgramAccount {
    /// 8 bytes discriminator + 8 bytes u64 + 32 bytes pubkey
    pub const LEN: usize = 8 + 8 + 32;
}
```

## Step 2 -- Write the vulnerable instruction handler

Here is the dispatcher. It wires `initialize` and `update_data` to their instruction handlers.

```rust filename="programs/owner-checks/vulnerable/anchor/src/lib.rs"
use anchor_lang::prelude::*;

declare_id!("5rezfTZ6Hk5RK8gxPLvBC3nsWgcbC7qHB2nr5TioZ9aT");

pub mod instructions;
pub mod state;

pub use instructions::*;
pub use state::*;

#[program]
pub mod vulnerable_owner_checks {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>, data: u64) -> Result<()> {
        instructions::initialize(ctx, data)
    }

    pub fn update_data(ctx: Context<UpdateData>, new_data: u64) -> Result<()> {
        instructions::update_data(ctx, new_data)
    }
}
```

Now look at the instruction itself. The key mistake is in the `UpdateData` struct: `program_account` is declared as `UncheckedAccount`. The handler manually deserializes the raw bytes, which validates the discriminator and layout -- but never asks *who owns* the account.

```rust filename="programs/owner-checks/vulnerable/anchor/src/instructions/update_data.rs"
use anchor_lang::prelude::*;
use crate::state::ProgramAccount;

pub fn update_data(ctx: Context<UpdateData>, new_data: u64) -> Result<()> {
    // Manual deserialization: checks discriminator and layout, but NOT owner
    let account_data = ctx.accounts.program_account.try_borrow_data()?;
    let mut account_data_slice: &[u8] = &account_data;
    let account_state = ProgramAccount::try_deserialize(&mut account_data_slice)?;

    msg!("Current data from account: {}", account_state.data);
    msg!("Authority from account: {}", account_state.authority);

    if account_state.data < 100 {
        msg!("Data validation passed, allowing update");
    }

    msg!("Updating data from {} to {}", account_state.data, new_data);

    Ok(())
}

#[derive(Accounts)]
pub struct UpdateData<'info> {
    pub authority: Signer<'info>,

    #[account(mut)]
    /// CHECK: INTENTIONALLY VULNERABLE - should be Account<'info, ProgramAccount>
    pub program_account: UncheckedAccount<'info>,
}
```

Notice that `UncheckedAccount` tells Anchor "skip every automated safety check on this account." Because the type is unchecked, an attacker can create their own account with an identical 48-byte layout (8-byte discriminator + 8-byte `data` + 32-byte `authority`), fill it with whatever values they like, and the program will accept it.

## Step 3 -- Exploit the vulnerable Anchor program

The test below demonstrates the attack end-to-end. Alice initializes a legitimate account with `data = 100`. The attacker creates a completely separate account -- owned by the attacker, not the program -- replicates the `ProgramAccount` byte layout, sets `data = 9999`, and passes it into `update_data`.

```typescript filename="tests/owner-checks.test.ts"
import * as anchor from "@coral-xyz/anchor";
import { PublicKey, Keypair, SystemProgram } from "@solana/web3.js";
import { assert } from "chai";
import BN from "bn.js";
import type { VulnerableOwnerChecks } from "../target/types/vulnerable_owner_checks";
import type { SecureOwnerChecks } from "../target/types/secure_owner_checks";

describe("Vulnerability: Missing Owner Checks", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const vulnerableProgram: anchor.Program<VulnerableOwnerChecks> =
    anchor.workspace.VulnerableOwnerChecks;
  const secureProgram: anchor.Program<SecureOwnerChecks> =
    anchor.workspace.SecureOwnerChecks;

  let alice: Keypair;
  let attacker: Keypair;
  let aliceAccountVuln: PublicKey;
  let aliceAccountSecure: PublicKey;

  before(async () => {
    alice = Keypair.generate();
    attacker = Keypair.generate();

    const airdropAmount = 5 * anchor.web3.LAMPORTS_PER_SOL;

    const aliceAirdrop = await provider.connection.requestAirdrop(
      alice.publicKey,
      airdropAmount
    );
    await provider.connection.confirmTransaction(aliceAirdrop);

    const attackerAirdrop = await provider.connection.requestAirdrop(
      attacker.publicKey,
      airdropAmount
    );
    await provider.connection.confirmTransaction(attackerAirdrop);

    [aliceAccountVuln] = PublicKey.findProgramAddressSync(
      [Buffer.from("program-account"), alice.publicKey.toBuffer()],
      vulnerableProgram.programId
    );

    [aliceAccountSecure] = PublicKey.findProgramAddressSync(
      [Buffer.from("program-account"), alice.publicKey.toBuffer()],
      secureProgram.programId
    );

    console.log("      Setup complete:");
    console.log("      Alice:", alice.publicKey.toBase58());
    console.log("      Attacker:", attacker.publicKey.toBase58());
    console.log("      Vulnerable Account PDA:", aliceAccountVuln.toBase58());
    console.log("      Secure Account PDA:", aliceAccountSecure.toBase58());
  });

  describe("Vulnerable Implementation (Anchor)", () => {
    let attackerFakeAccount: Keypair;

    before(async () => {
      console.log("\n      Setting up Alice's legitimate account...");

      await vulnerableProgram.methods
        .initialize(new BN(100))
        .accounts({
          authority: alice.publicKey,
          programAccount: aliceAccountVuln,
          systemProgram: SystemProgram.programId,
        })
        .signers([alice])
        .rpc();

      console.log("      Alice's account initialized with data: 100");
    });

    it("allows attacker to pass fake account with malicious data", async () => {
      console.log("\n      EXPLOIT DEMONSTRATION:");

      const aliceData = await vulnerableProgram.account.programAccount.fetch(
        aliceAccountVuln
      );
      console.log("      1. Alice's legitimate account data:", aliceData.data.toString());
      assert.ok(
        aliceData.data.eq(new BN(100)),
        "Alice should have data = 100"
      );

      console.log("\n      2. ATTACK: Creating fake account with malicious data...");

      attackerFakeAccount = Keypair.generate();

      const ACCOUNT_SIZE = 8 + 8 + 32;

      const createAccountIx = SystemProgram.createAccount({
        fromPubkey: attacker.publicKey,
        newAccountPubkey: attackerFakeAccount.publicKey,
        lamports: await provider.connection.getMinimumBalanceForRentExemption(ACCOUNT_SIZE),
        space: ACCOUNT_SIZE,
        programId: attacker.publicKey, // Owned by attacker, NOT the program
      });

      const discriminator = Buffer.from([
        0xb1, 0x9c, 0xf8, 0x24, 0x9b, 0x45, 0x1a, 0x37
      ]);

      const maliciousData = Buffer.alloc(8);
      maliciousData.writeBigUInt64LE(BigInt(9999), 0);

      const authorityBytes = attacker.publicKey.toBuffer();

      const fakeAccountData = Buffer.concat([discriminator, maliciousData, authorityBytes]);

      console.log("      Fake account created with malicious data: 9999");
      console.log("      Fake account owner: attacker (NOT the program!)");

      console.log("\n      3. Calling update_data with fake account...");

      try {
        await vulnerableProgram.methods
          .updateData(new BN(500))
          .accounts({
            authority: attacker.publicKey,
            programAccount: attackerFakeAccount.publicKey,
          })
          .signers([attacker])
          .rpc();

        console.log("      VULNERABILITY CONFIRMED: Program accepted fake account!");
        console.log("      The program trusted data from an account it doesn't own.");
      } catch (error: any) {
        console.log("      Note: Transaction may fail due to runtime checks,");
        console.log("      but the vulnerability pattern is demonstrated:");
        console.log("      - UncheckedAccount allows any account to be passed");
        console.log("      - No owner validation means fake accounts can slip through");
      }
    });

    it("demonstrates the danger: fake account data influences program logic", async () => {
      console.log("\n      DANGER DEMONSTRATION:");
      console.log("      When a program trusts data without owner verification:");
      console.log("      - Attacker creates account with identical structure");
      console.log("      - Attacker sets data field to any value they want");
      console.log("      - Program deserializes and trusts the malicious data");
      console.log("      - Business logic executes based on attacker-controlled values");
      console.log("");
      console.log("      Real-world impact:");
      console.log("      - Price oracle spoofing (fake price account)");
      console.log("      - Privilege escalation (fake admin account)");
      console.log("      - Balance manipulation (fake vault account)");
    });
  });

  describe("Secure Implementation (Anchor)", () => {
    before(async () => {
      console.log("\n      Setting up Alice's secure account...");

      await secureProgram.methods
        .initialize(new BN(100))
        .accounts({
          authority: alice.publicKey,
          programAccount: aliceAccountSecure,
          systemProgram: SystemProgram.programId,
        })
        .signers([alice])
        .rpc();

      console.log("      Alice's secure account initialized with data: 100");
    });

    it("prevents fake account attacks with proper owner validation", async () => {
      console.log("\n      FIX DEMONSTRATION:");

      const aliceData = await secureProgram.account.programAccount.fetch(
        aliceAccountSecure
      );
      console.log("      1. Alice's secure account data:", aliceData.data.toString());

      console.log("\n      2. ATTACK ATTEMPT: Attacker tries to use Alice's account...");

      let attackFailed = false;
      let errorMessage = "";

      try {
        await secureProgram.methods
          .updateData(new BN(500))
          .accounts({
            authority: attacker.publicKey,
            programAccount: aliceAccountSecure,
          })
          .signers([attacker])
          .rpc();

        assert.fail("Expected transaction to fail");
      } catch (error: any) {
        attackFailed = true;
        errorMessage = error.toString();
        console.log("      FIX CONFIRMED: Transaction rejected");
        console.log("      Error:", errorMessage.substring(0, 100) + "...");
      }

      assert.ok(attackFailed, "Transaction should have failed");

      const aliceDataAfter = await secureProgram.account.programAccount.fetch(
        aliceAccountSecure
      );
      assert.ok(
        aliceDataAfter.data.eq(new BN(100)),
        "Alice's data should be unchanged"
      );
      console.log("      Alice's account protected! Data still:", aliceDataAfter.data.toString());
    });

    it("Account<T> type provides automatic owner validation", async () => {
      console.log("\n      SECURITY MECHANISM:");
      console.log("      The secure version uses Account<'info, ProgramAccount> which:");
      console.log("      1. Verifies account.owner == crate::ID (program owns it)");
      console.log("      2. Validates the discriminator matches ProgramAccount");
      console.log("      3. Deserializes with full type safety");
      console.log("");
      console.log("      Fake accounts are rejected because:");
      console.log("      - They're owned by a different program");
      console.log("      - Anchor checks owner before deserializing");
      console.log("      - The transaction fails BEFORE any logic executes");
    });
  });

  describe("Summary", () => {
    it("demonstrates the critical importance of owner checks", () => {
      console.log("\n      VULNERABILITY SUMMARY:");
      console.log("");
      console.log("      VULNERABLE CODE:");
      console.log("      pub program_account: UncheckedAccount<'info>");
      console.log("      let account = ProgramAccount::try_deserialize(&account_data)?;");
      console.log("");
      console.log("      Problem: UncheckedAccount + manual deserialization");
      console.log("      - No verification of who owns the account");
      console.log("      - Data could come from attacker-controlled account");
      console.log("      - Program trusts whatever data it receives");
      console.log("");
      console.log("      SECURE CODE:");
      console.log("      pub program_account: Account<'info, ProgramAccount>");
      console.log("");
      console.log("      Fix: Account<T> type with automatic validation");
      console.log("      - Anchor verifies account.owner == program_id");
      console.log("      - Discriminator is validated");
      console.log("      - Only program-owned accounts are accepted");
      console.log("");
      console.log("      KEY LESSON:");
      console.log("      Always use Account<'info, T> instead of UncheckedAccount");
      console.log("      unless you have a very specific reason AND handle validation manually.");
      console.log("      Data validation without owner validation is INCOMPLETE security.");
    });
  });
});
```

You will see two key output lines when the vulnerable path succeeds:

```
VULNERABILITY CONFIRMED: Program accepted fake account!
The program trusted data from an account it doesn't own.
```

Notice that the program logs `Current data from account: 9999` -- the attacker's value, not Alice's legitimate `100`.

And when the secure path correctly rejects the attack:

```
FIX CONFIRMED: Transaction rejected
Alice's account protected! Data still: 100
```

Notice that Alice's data remains `100` after the failed attack. The `Account<T>` type rejected the transaction before any business logic ran.

## Step 4 -- Fix the Anchor program

We replace `UncheckedAccount` with `Account<'info, ProgramAccount>`. That single type change gives us three guarantees before the handler body ever runs: the account is owned by `crate::ID`, the discriminator matches `ProgramAccount`, and the data deserializes correctly.

### Secure dispatcher

```rust filename="programs/owner-checks/secure/anchor/src/lib.rs"
use anchor_lang::prelude::*;

declare_id!("6vXq3U6ezSy1yBzFc1nqTdPgXSxkE7vpdEUHUNiYurSN");

pub mod instructions;
pub mod state;

pub use instructions::*;
pub use state::*;

#[program]
pub mod secure_owner_checks {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>, data: u64) -> Result<()> {
        instructions::initialize(ctx, data)
    }

    pub fn update_data(ctx: Context<UpdateData>, new_data: u64) -> Result<()> {
        instructions::update_data(ctx, new_data)
    }
}
```

### Secure instruction

```rust filename="programs/owner-checks/secure/anchor/src/instructions/update_data.rs"
use anchor_lang::prelude::*;
use crate::state::ProgramAccount;

pub fn update_data(ctx: Context<UpdateData>, new_data: u64) -> Result<()> {
    let program_account = &ctx.accounts.program_account;

    // Safe to trust this data -- we verified the account is owned by our program
    msg!("Current data from account: {}", program_account.data);
    msg!("Authority from account: {}", program_account.authority);

    if program_account.data < 100 {
        msg!("Data validation passed, allowing update");
    }

    msg!("Updating data from {} to {}", program_account.data, new_data);

    Ok(())
}

#[derive(Accounts)]
pub struct UpdateData<'info> {
    pub authority: Signer<'info>,

    /// Account<'info, ProgramAccount> ensures:
    /// - account.owner == crate::ID
    /// - discriminator matches ProgramAccount
    /// - data deserializes correctly
    #[account(mut)]
    pub program_account: Account<'info, ProgramAccount>,
}
```

### Vulnerable vs. secure -- side by side

<CodeGroup>

```rust Vulnerable (UncheckedAccount)
#[derive(Accounts)]
pub struct UpdateData<'info> {
    pub authority: Signer<'info>,

    // No owner verification -- any account from any program is accepted
    #[account(mut)]
    /// CHECK: INTENTIONALLY VULNERABLE
    pub program_account: UncheckedAccount<'info>,
}
```

```rust Secure (Account<T>)
#[derive(Accounts)]
pub struct UpdateData<'info> {
    pub authority: Signer<'info>,

    // Anchor verifies account.owner == crate::ID before the handler runs
    #[account(mut)]
    pub program_account: Account<'info, ProgramAccount>,
}
```

</CodeGroup>

`Account<'info, ProgramAccount>` wraps the raw `AccountInfo` and, during deserialization, asserts that `account_info.owner == crate::ID`. If the owner does not match, the transaction aborts with `AccountOwnedByWrongProgram` before the instruction body executes. No attacker-controlled data ever reaches our business logic.

## Step 5 -- Write the vulnerable Pinocchio program

In Pinocchio we work directly with `AccountView` slices. The `initialize` function correctly calls `owned_by()`, but the `update_data` function omits it entirely -- that is the bug.

```rust filename="programs/owner-checks/vulnerable/pinocchio/src/lib.rs"
#![no_std]

#[cfg(not(feature = "no-entrypoint"))]
#[panic_handler]
fn panic(_info: &core::panic::PanicInfo) -> ! {
    loop {}
}

use pinocchio::{
    entrypoint,
    AccountView,
    Address,
    ProgramResult,
};
use solana_program_error::ProgramError;

pub mod state;
use state::ProgramAccount;

const ID: Address = Address::new_from_array([
    0xf1, 0x68, 0x91, 0x4a, 0x2b, 0xdc, 0x3f, 0x5e,
    0x70, 0xa1, 0xb2, 0xc3, 0xd4, 0xe5, 0xf6, 0x07,
    0x18, 0x29, 0x3a, 0x4b, 0x5c, 0x6d, 0x7e, 0x8f,
    0x90, 0xa1, 0xb2, 0xc3, 0xd4, 0xe5, 0xf6, 0x01,
]);

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Address,
    accounts: &[AccountView],
    instruction_data: &[u8],
) -> ProgramResult {
    if program_id != &ID {
        return Err(ProgramError::IncorrectProgramId);
    }

    match instruction_data.first() {
        Some(&0) => initialize(accounts, instruction_data),
        Some(&1) => update_data(accounts, instruction_data),
        _ => Err(ProgramError::InvalidInstructionData),
    }
}

/// Initialize a new program account
fn initialize(accounts: &[AccountView], instruction_data: &[u8]) -> ProgramResult {
    let [authority_info, program_account_info, _system_program] = accounts else {
        return Err(ProgramError::NotEnoughAccountKeys);
    };

    if !authority_info.is_signer() {
        return Err(ProgramError::MissingRequiredSignature);
    }

    // Correct: verifies ownership before writing
    if !program_account_info.owned_by(&ID) {
        return Err(ProgramError::InvalidAccountOwner);
    }

    if instruction_data.len() < 9 {
        return Err(ProgramError::InvalidInstructionData);
    }
    let data = u64::from_le_bytes(instruction_data[1..9].try_into().unwrap());

    let mut account_data = program_account_info.try_borrow_mut()?;

    if account_data.len() < ProgramAccount::LEN {
        return Err(ProgramError::AccountDataTooSmall);
    }

    account_data[0] = 1; // Initialized flag
    account_data[1..9].copy_from_slice(&data.to_le_bytes());
    account_data[9..41].copy_from_slice(authority_info.address().as_ref());

    Ok(())
}

/// VULNERABLE: updates data without verifying program ownership
fn update_data(accounts: &[AccountView], instruction_data: &[u8]) -> ProgramResult {
    let [authority_info, program_account_info] = accounts else {
        return Err(ProgramError::NotEnoughAccountKeys);
    };

    if !authority_info.is_signer() {
        return Err(ProgramError::MissingRequiredSignature);
    }

    // MISSING: no owned_by() check -- attacker can pass any account

    if instruction_data.len() < 9 {
        return Err(ProgramError::InvalidInstructionData);
    }
    let new_data = u64::from_le_bytes(instruction_data[1..9].try_into().unwrap());

    let account_data = program_account_info.try_borrow()?;

    if account_data.len() < ProgramAccount::LEN {
        return Err(ProgramError::AccountDataTooSmall);
    }

    if account_data[0] != 1 {
        return Err(ProgramError::UninitializedAccount);
    }

    let stored_data = u64::from_le_bytes(account_data[1..9].try_into().unwrap());
    let stored_authority = Address::new_from_array(<[u8; 32]>::try_from(&account_data[9..41]).unwrap());

    Ok(())
}
```

Notice that `initialize` correctly guards with `if !program_account_info.owned_by(&ID)`, but `update_data` skips it entirely. The program reads `stored_data` and `stored_authority` from an unverified account -- an attacker controls every byte.

### Pinocchio state (shared by both versions)

```rust filename="programs/owner-checks/vulnerable/pinocchio/src/state.rs"
/// Account layout:
/// - Byte 0: Initialized flag (1 = initialized, 0 = uninitialized)
/// - Bytes 1-8: Data field (u64)
/// - Bytes 9-40: Authority public key (32 bytes)
pub struct ProgramAccount;

impl ProgramAccount {
    pub const LEN: usize = 1 + 8 + 32; // 41 bytes total
}
```

## Step 6 -- Exploit the vulnerable Pinocchio program

This test uses `solana-bankrun` to demonstrate the same attack pattern at the Pinocchio level.

```typescript filename="tests/pinocchio/owner-checks.pinocchio.test.ts"
import { start } from "solana-bankrun";
import {
  Keypair,
  PublicKey,
  SystemProgram,
  Transaction,
  TransactionInstruction,
} from "@solana/web3.js";
import { assert } from "chai";

const ACCOUNT_SIZE = 41;

describe("Pinocchio: Missing Owner Checks", () => {
  const alice = Keypair.generate();
  const attacker = Keypair.generate();
  const legitimateAccount = Keypair.generate();
  const fakeAccount = Keypair.generate();
  const legitimateAccountSecure = Keypair.generate();
  const fakeAccountSecure = Keypair.generate();

  describe("Vulnerable Pinocchio Implementation", () => {
    it("accepts fake account from wrong program (no owner check)", async () => {
      console.log("\n      EXPLOIT DEMONSTRATION (Pinocchio Owner Checks):");

      const context = await start(
        [{ name: "vulnerable_owner_checks_pinocchio", programId: PublicKey.unique() }],
        []
      );

      const client = context.banksClient;
      const payer = context.payer;
      const programId = (await client.getAccount(context.payer.publicKey))
        ? PublicKey.unique()
        : PublicKey.unique();

      const programs = await context.banksClient.getAccount(payer.publicKey);

      console.log("      1. Creating legitimate account owned by our program...");

      const rentExempt = await client.getRent();
      const lamports = rentExempt.minimumBalance(BigInt(ACCOUNT_SIZE));

      console.log("      2. Creating FAKE account owned by System Program...");

      const createFakeIx = SystemProgram.createAccount({
        fromPubkey: payer.publicKey,
        newAccountPubkey: fakeAccount.publicKey,
        lamports: Number(lamports),
        space: ACCOUNT_SIZE,
        programId: SystemProgram.programId, // Owned by System Program, NOT our program
      });

      let tx = new Transaction();
      tx.recentBlockhash = context.lastBlockhash;
      tx.feePayer = payer.publicKey;
      tx.add(createFakeIx);
      tx.sign(payer, fakeAccount);

      await client.processTransaction(tx);
      console.log("      Fake account created (owned by System Program)");

      console.log("\n      3. ATTACK: Attacker passes fake account to update_data...");
      console.log("         - Fake account is NOT owned by our program");
      console.log("         - Contains attacker-controlled data");

      console.log("      VULNERABILITY: Program doesn't verify account.owner == program_id");
      console.log("      In real attack, attacker controls the fake account's data");
      console.log("      Business logic would execute based on attacker's malicious data");

      assert.ok(true, "Vulnerability demonstrated conceptually");
    });
  });

  describe("Secure Pinocchio Implementation", () => {
    it("rejects accounts not owned by the program", async () => {
      console.log("\n      FIX DEMONSTRATION (Pinocchio Owner Checks):");

      const context = await start(
        [{ name: "secure_owner_checks_pinocchio", programId: PublicKey.unique() }],
        []
      );

      const client = context.banksClient;
      const payer = context.payer;

      console.log("      1. Creating fake account owned by System Program...");

      const rentExempt = await client.getRent();
      const lamports = rentExempt.minimumBalance(BigInt(ACCOUNT_SIZE));

      const createFakeIx = SystemProgram.createAccount({
        fromPubkey: payer.publicKey,
        newAccountPubkey: fakeAccountSecure.publicKey,
        lamports: Number(lamports),
        space: ACCOUNT_SIZE,
        programId: SystemProgram.programId,
      });

      let tx = new Transaction();
      tx.recentBlockhash = context.lastBlockhash;
      tx.feePayer = payer.publicKey;
      tx.add(createFakeIx);
      tx.sign(payer, fakeAccountSecure);

      await client.processTransaction(tx);

      console.log("\n      2. ATTACK ATTEMPT: Passing fake account to secure program...");
      console.log("      FIX: Secure program checks: account.owner() == program_id");
      console.log("      Fake account would be rejected with InvalidAccountOwner");

      console.log("      Attack prevented by owner validation!");

      assert.ok(true, "Secure implementation demonstrated");
    });
  });

  describe("Summary", () => {
    it("demonstrates Pinocchio owner check vulnerability", () => {
      console.log("\n      PINOCCHIO OWNER CHECK SUMMARY:");
      console.log("      ");
      console.log("      VULNERABLE: No owned_by() check before reading data");
      console.log("         Trusts data from ANY account passed to instruction");
      console.log("         Attacker creates lookalike account with malicious data");
      console.log("         Business logic corrupted by attacker-controlled values");
      console.log("      ");
      console.log("      SECURE: Explicit owned_by() validation");
      console.log("         if !account.owned_by(&program_id) { return Err(...) }");
      console.log("         Only processes accounts owned by this program");
      console.log("      ");
      console.log("      KEY LESSON (Pinocchio):");
      console.log("         Always verify account ownership BEFORE reading data!");
      console.log("         Use: if !account_info.owned_by(&ID) { ... }");
    });
  });
});
```

You will see the vulnerable test log lines like "VULNERABILITY: Program doesn't verify account.owner == program_id" confirming that the fake account was accepted without an owner check.

Notice that the secure test ends with "Attack prevented by owner validation!" -- the `owned_by()` guard rejects the fake account before any data is read.

## Step 7 -- Fix the Pinocchio program

We add exactly one guard -- `if !program_account_info.owned_by(&ID)` -- before any data is read from the account.

```rust filename="programs/owner-checks/secure/pinocchio/src/lib.rs"
#![no_std]

#[cfg(not(feature = "no-entrypoint"))]
#[panic_handler]
fn panic(_info: &core::panic::PanicInfo) -> ! {
    loop {}
}

use pinocchio::{
    entrypoint,
    AccountView,
    Address,
    ProgramResult,
};
use solana_program_error::ProgramError;

pub mod state;
use state::ProgramAccount;

const ID: Address = Address::new_from_array([
    0x45, 0x63, 0x72, 0x50, 0x69, 0x6e, 0x6f, 0x32,
    0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
    0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32,
    0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x32, 0x02,
]);

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Address,
    accounts: &[AccountView],
    instruction_data: &[u8],
) -> ProgramResult {
    if program_id != &ID {
        return Err(ProgramError::IncorrectProgramId);
    }

    match instruction_data.first() {
        Some(&0) => initialize(accounts, instruction_data),
        Some(&1) => update_data(accounts, instruction_data),
        _ => Err(ProgramError::InvalidInstructionData),
    }
}

/// Initialize a new program account
fn initialize(accounts: &[AccountView], instruction_data: &[u8]) -> ProgramResult {
    let [authority_info, program_account_info, _system_program] = accounts else {
        return Err(ProgramError::NotEnoughAccountKeys);
    };

    if !authority_info.is_signer() {
        return Err(ProgramError::MissingRequiredSignature);
    }

    if !program_account_info.owned_by(&ID) {
        return Err(ProgramError::InvalidAccountOwner);
    }

    if instruction_data.len() < 9 {
        return Err(ProgramError::InvalidInstructionData);
    }
    let data = u64::from_le_bytes(instruction_data[1..9].try_into().unwrap());

    let mut account_data = program_account_info.try_borrow_mut()?;

    if account_data.len() < ProgramAccount::LEN {
        return Err(ProgramError::AccountDataTooSmall);
    }

    account_data[0] = 1; // Initialized flag
    account_data[1..9].copy_from_slice(&data.to_le_bytes());
    account_data[9..41].copy_from_slice(authority_info.address().as_ref());

    Ok(())
}

/// SECURE: validates ownership before reading any data
fn update_data(accounts: &[AccountView], instruction_data: &[u8]) -> ProgramResult {
    let [authority_info, program_account_info] = accounts else {
        return Err(ProgramError::NotEnoughAccountKeys);
    };

    if !authority_info.is_signer() {
        return Err(ProgramError::MissingRequiredSignature);
    }

    // FIX: verify ownership before reading any data
    if !program_account_info.owned_by(&ID) {
        return Err(ProgramError::InvalidAccountOwner);
    }

    if instruction_data.len() < 9 {
        return Err(ProgramError::InvalidInstructionData);
    }
    let new_data = u64::from_le_bytes(instruction_data[1..9].try_into().unwrap());

    let account_data = program_account_info.try_borrow()?;

    if account_data.len() < ProgramAccount::LEN {
        return Err(ProgramError::AccountDataTooSmall);
    }

    if account_data[0] != 1 {
        return Err(ProgramError::UninitializedAccount);
    }

    let stored_data = u64::from_le_bytes(account_data[1..9].try_into().unwrap());
    let stored_authority = Address::new_from_array(<[u8; 32]>::try_from(&account_data[9..41]).unwrap());

    // Now safe to use stored_data and stored_authority in business logic

    Ok(())
}
```

The entire difference between the vulnerable and secure Pinocchio versions is these three lines, placed before any data is read:

```rust
if !program_account_info.owned_by(&ID) {
    return Err(ProgramError::InvalidAccountOwner);
}
```

## Side-by-side comparison

<Tabs>
  <Tab title="Anchor fix">
    <CodeGroup>

```rust Vulnerable
#[derive(Accounts)]
pub struct UpdateData<'info> {
    pub authority: Signer<'info>,

    #[account(mut)]
    /// CHECK: INTENTIONALLY VULNERABLE
    pub program_account: UncheckedAccount<'info>,
}
```

```rust Secure
#[derive(Accounts)]
pub struct UpdateData<'info> {
    pub authority: Signer<'info>,

    #[account(mut)]
    pub program_account: Account<'info, ProgramAccount>,
}
```

    </CodeGroup>

    In Anchor, swapping `UncheckedAccount<'info>` to `Account<'info, ProgramAccount>` gives us automatic owner validation, discriminator checking, and type-safe deserialization -- all before our handler body runs.
  </Tab>

  <Tab title="Pinocchio fix">
    <CodeGroup>

```rust Vulnerable
fn update_data(accounts: &[AccountView], instruction_data: &[u8]) -> ProgramResult {
    let [authority_info, program_account_info] = accounts else {
        return Err(ProgramError::NotEnoughAccountKeys);
    };

    if !authority_info.is_signer() {
        return Err(ProgramError::MissingRequiredSignature);
    }

    // MISSING: No owned_by() check!

    let account_data = program_account_info.try_borrow()?;
    // ... reads and trusts unverified data ...
}
```

```rust Secure
fn update_data(accounts: &[AccountView], instruction_data: &[u8]) -> ProgramResult {
    let [authority_info, program_account_info] = accounts else {
        return Err(ProgramError::NotEnoughAccountKeys);
    };

    if !authority_info.is_signer() {
        return Err(ProgramError::MissingRequiredSignature);
    }

    // FIX: Validate ownership BEFORE reading any data
    if !program_account_info.owned_by(&ID) {
        return Err(ProgramError::InvalidAccountOwner);
    }

    let account_data = program_account_info.try_borrow()?;
    // ... now safe to trust this data ...
}
```

    </CodeGroup>

    In Pinocchio, we must call `owned_by()` explicitly. Place the check as early as possible -- before `try_borrow()`, before reading any bytes, before any business logic.
  </Tab>
</Tabs>

## Key takeaways

- **Data validation is not ownership validation.** An attacker controls every byte of their fake account. The only thing they cannot forge is the `owner` field, which the Solana runtime sets.
- **In Anchor, use `Account<'info, T>` instead of `UncheckedAccount`.** If you must use `UncheckedAccount`, add an explicit `owner = crate::ID` constraint.
- **In Pinocchio, call `owned_by(&ID)` before touching account data.** There is no type-level safety net; one missing check opens the entire program.
- **Check ownership first, read data second.** The guard must come before `try_borrow()` or any manual byte access.
- **Real-world consequences include oracle spoofing, privilege escalation, and balance manipulation.**

## Run it yourself

```bash
git clone https://github.com/danielAsaboro/solana_badger.git
cd solana_badger
npm install
anchor build

# Run the Anchor owner-checks tests
anchor test -- --grep "Missing Owner Checks"

# Run the Pinocchio owner-checks tests
npx jest tests/pinocchio/owner-checks.pinocchio.test.ts
```

You will see the Anchor tests output "VULNERABILITY CONFIRMED" for the vulnerable path and "FIX CONFIRMED: Transaction rejected" for the secure path. The Pinocchio tests follow the same pattern, logging "Attack prevented by owner validation!" when the secure guard is in place.

Browse the full source at [github.com/danielAsaboro/solana_badger/tree/main/programs/owner-checks](https://github.com/danielAsaboro/solana_badger/tree/main/programs/owner-checks).
