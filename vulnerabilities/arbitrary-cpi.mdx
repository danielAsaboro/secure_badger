---
title: "Arbitrary CPI"
description: "How unvalidated cross-program invocations let attackers substitute malicious programs and steal funds"
icon: "arrows-rotate"
---

Cross-Program Invocations (CPIs) are the backbone of composability on Solana. But if we invoke a program without verifying its identity, an attacker can swap in a malicious substitute that reverses transfers, drains funds, or hijacks authority. In this tutorial we will build a vulnerable token vault, exploit it, and then fix it -- in both Anchor and Pinocchio.

## What we will build

- A token vault program that transfers tokens via CPI to an **unvalidated** program account
- A test that proves an attacker can pass an arbitrary program ID through the validation layer
- A secure version that pins the CPI target to the real SPL Token program, blocking the attack

<Note>
  **Prerequisites** -- Before starting, clone the repository and install dependencies:

  ```bash
  git clone https://github.com/danielAsaboro/solana_badger.git
  cd solana_badger
  npm install
  ```

  You will need Anchor, the Solana CLI, and Node.js already installed.
</Note>

## Step 1: Understand the vulnerable program (Anchor)

We start with a vault that accepts a `token_program` account as `UncheckedAccount`. This means the runtime will accept whatever program ID the caller provides -- no questions asked.

<CodeGroup>
```rust transfer_tokens.rs
use anchor_lang::prelude::*;
use anchor_lang::solana_program::{self, instruction::{AccountMeta, Instruction}};
use anchor_spl::token::TokenAccount;
use crate::state::Vault;

pub fn transfer_tokens(ctx: Context<TransferTokens>, amount: u64) -> Result<()> {
    msg!("Transferring {} tokens from vault", amount);
    msg!("WARNING: Using arbitrary program without validation!");

    // Manually construct SPL Token transfer instruction
    // Instruction index 3 = Transfer in SPL Token program
    let mut data = vec![3u8];
    data.extend_from_slice(&amount.to_le_bytes());

    let transfer_ix = Instruction {
        program_id: ctx.accounts.token_program.key(),
        accounts: vec![
            AccountMeta::new(ctx.accounts.source.key(), false),
            AccountMeta::new(ctx.accounts.destination.key(), false),
            AccountMeta::new_readonly(ctx.accounts.authority.key(), true),
        ],
        data,
    };

    solana_program::program::invoke(
        &transfer_ix,
        &[
            ctx.accounts.source.to_account_info(),
            ctx.accounts.destination.to_account_info(),
            ctx.accounts.authority.to_account_info(),
            ctx.accounts.token_program.to_account_info(),
        ],
    )?;

    msg!("Transfer completed (or was it?)");
    Ok(())
}

#[derive(Accounts)]
pub struct TransferTokens<'info> {
    pub authority: Signer<'info>,

    #[account(
        seeds = [b"vault", authority.key().as_ref()],
        bump = vault.bump,
        constraint = vault.authority == authority.key() @ ErrorCode::UnauthorizedAuthority
    )]
    pub vault: Account<'info, Vault>,

    #[account(
        mut,
        constraint = source.key() == vault.token_account @ ErrorCode::InvalidSourceAccount
    )]
    pub source: Account<'info, TokenAccount>,

    #[account(mut)]
    pub destination: Account<'info, TokenAccount>,

    /// CHECK: This account is NOT checked -- that is the vulnerability.
    pub token_program: UncheckedAccount<'info>,
}

#[error_code]
pub enum ErrorCode {
    #[msg("Only the vault authority can authorize transfers")]
    UnauthorizedAuthority,

    #[msg("Source must be the vault's token account")]
    InvalidSourceAccount,
}
```

```rust state.rs
use anchor_lang::prelude::*;

#[account]
pub struct Vault {
    pub authority: Pubkey,
    pub token_account: Pubkey,
    pub bump: u8,
}

impl Vault {
    pub const LEN: usize = 8 + // discriminator
        32 + // authority
        32 + // token_account
        1; // bump
}
```

```rust lib.rs (dispatcher)
use anchor_lang::prelude::*;

declare_id!("J9nJgXQ2pckccZdRb6zuRXJiupqF7AJN7yFzzJTHepkz");

pub mod instructions;
pub mod state;

pub use instructions::*;
pub use state::*;

#[program]
pub mod vulnerable_arbitrary_cpi {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        instructions::initialize(ctx)
    }

    pub fn transfer_tokens(ctx: Context<TransferTokens>, amount: u64) -> Result<()> {
        instructions::transfer_tokens(ctx, amount)
    }
}
```
</CodeGroup>

The critical line is in the `TransferTokens` accounts struct:

```rust
pub token_program: UncheckedAccount<'info>,
```

Notice that the program validates the signer, the vault PDA, and the source token account. All of those checks pass. But the program that actually executes the transfer is entirely attacker-controlled -- `UncheckedAccount` performs zero validation on the program ID.

## Step 2: Exploit the vulnerability

Now we write a test that passes `attacker.publicKey` as the `tokenProgram` account. Because the program uses `UncheckedAccount`, it accepts this arbitrary key without complaint.

```typescript
it("demonstrates vulnerability: UncheckedAccount accepts ANY program ID", async () => {
  const vaultBefore = await getAccount(provider.connection, vaultTokenAccount);

  let errorMessage = "";
  try {
    await vulnerableProgram.methods
      .transferTokens(new BN(TRANSFER_AMOUNT))
      .accounts({
        authority: authority.publicKey,
        source: vaultTokenAccount,
        destination: destinationTokenAccount,
        tokenProgram: attacker.publicKey, // ATTACK: Wrong program!
      })
      .signers([authority])
      .rpc();
  } catch (error: unknown) {
    errorMessage = error instanceof Error ? error.message : String(error);
  }

  const vaultAfter = await getAccount(provider.connection, vaultTokenAccount);
  assert.equal(
    Number(vaultBefore.amount),
    Number(vaultAfter.amount),
    "Vault balance should be unchanged (CPI failed)"
  );
});
```

You will see output similar to:

```bash
VULNERABILITY DEMONSTRATION:
  The vulnerable program uses UncheckedAccount<'info> for token_program.
  This allows ANY program ID to be passed without validation.

  ATTACK: Passing attacker's pubkey as token_program...
  Transaction failed at CPI level (expected)

  VULNERABILITY CONFIRMED:
  - Program accepted arbitrary program ID
  - Failed only because attacker.publicKey isn't a deployed program
  - A malicious program with same interface would execute!
```

Notice that the vault did not lose tokens only because the attacker key is not an executable program. If the attacker had deployed a program at that address with the same instruction layout, the CPI would have succeeded and tokens would have moved wherever the malicious program directed them.

## Step 3: Fix the vulnerability (Anchor)

We replace `UncheckedAccount<'info>` with `Program<'info, Token>`. Anchor will automatically reject any account whose key does not match `spl_token::ID`.

<CodeGroup>
```rust Secure transfer_tokens.rs
use anchor_lang::prelude::*;
use anchor_spl::token::{self, Token, TokenAccount, Transfer};
use crate::state::Vault;

pub fn transfer_tokens(ctx: Context<TransferTokens>, amount: u64) -> Result<()> {
    msg!("Transferring {} tokens from vault", amount);
    msg!("Using validated Token program: {}", ctx.accounts.token_program.key());

    let cpi_accounts = Transfer {
        from: ctx.accounts.source.to_account_info(),
        to: ctx.accounts.destination.to_account_info(),
        authority: ctx.accounts.authority.to_account_info(),
    };
    let cpi_program = ctx.accounts.token_program.to_account_info();
    let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);

    token::transfer(cpi_ctx, amount)?;

    msg!("Transfer completed successfully");
    Ok(())
}

#[derive(Accounts)]
pub struct TransferTokens<'info> {
    pub authority: Signer<'info>,

    #[account(
        seeds = [b"vault", authority.key().as_ref()],
        bump = vault.bump,
        constraint = vault.authority == authority.key() @ ErrorCode::UnauthorizedAuthority
    )]
    pub vault: Account<'info, Vault>,

    #[account(
        mut,
        constraint = source.key() == vault.token_account @ ErrorCode::InvalidSourceAccount
    )]
    pub source: Account<'info, TokenAccount>,

    #[account(mut)]
    pub destination: Account<'info, TokenAccount>,

    /// FIX: Program<'info, Token> validates token_program.key() == spl_token::ID
    pub token_program: Program<'info, Token>,
}

#[error_code]
pub enum ErrorCode {
    #[msg("Only the vault authority can authorize transfers")]
    UnauthorizedAuthority,

    #[msg("Source must be the vault's token account")]
    InvalidSourceAccount,
}
```

```rust Vulnerable transfer_tokens.rs
use anchor_lang::prelude::*;
use anchor_lang::solana_program::{self, instruction::{AccountMeta, Instruction}};
use anchor_spl::token::TokenAccount;
use crate::state::Vault;

pub fn transfer_tokens(ctx: Context<TransferTokens>, amount: u64) -> Result<()> {
    msg!("Transferring {} tokens from vault", amount);
    msg!("WARNING: Using arbitrary program without validation!");

    let mut data = vec![3u8];
    data.extend_from_slice(&amount.to_le_bytes());

    let transfer_ix = Instruction {
        program_id: ctx.accounts.token_program.key(),
        accounts: vec![
            AccountMeta::new(ctx.accounts.source.key(), false),
            AccountMeta::new(ctx.accounts.destination.key(), false),
            AccountMeta::new_readonly(ctx.accounts.authority.key(), true),
        ],
        data,
    };

    solana_program::program::invoke(
        &transfer_ix,
        &[
            ctx.accounts.source.to_account_info(),
            ctx.accounts.destination.to_account_info(),
            ctx.accounts.authority.to_account_info(),
            ctx.accounts.token_program.to_account_info(),
        ],
    )?;

    msg!("Transfer completed (or was it?)");
    Ok(())
}

#[derive(Accounts)]
pub struct TransferTokens<'info> {
    pub authority: Signer<'info>,

    #[account(
        seeds = [b"vault", authority.key().as_ref()],
        bump = vault.bump,
        constraint = vault.authority == authority.key() @ ErrorCode::UnauthorizedAuthority
    )]
    pub vault: Account<'info, Vault>,

    #[account(
        mut,
        constraint = source.key() == vault.token_account @ ErrorCode::InvalidSourceAccount
    )]
    pub source: Account<'info, TokenAccount>,

    #[account(mut)]
    pub destination: Account<'info, TokenAccount>,

    /// CHECK: This account is NOT checked -- that is the vulnerability.
    pub token_program: UncheckedAccount<'info>,
}

#[error_code]
pub enum ErrorCode {
    #[msg("Only the vault authority can authorize transfers")]
    UnauthorizedAuthority,

    #[msg("Source must be the vault's token account")]
    InvalidSourceAccount,
}
```
</CodeGroup>

The entire fix is a single type change:

```rust
// Vulnerable
pub token_program: UncheckedAccount<'info>,

// Secure
pub token_program: Program<'info, Token>,
```

`Program<'info, Token>` asserts `token_program.key() == spl_token::ID` before any instruction handler runs. Any other program ID causes the transaction to fail immediately. The instruction body also improves -- instead of manually constructing a raw `Instruction` and calling `solana_program::program::invoke`, we use `anchor_spl::token::transfer` with a `CpiContext`, which adds another layer of type-safety.

## Step 4: Confirm the fix blocks the attack

The secure test proves that the same attack is now rejected:

```typescript
it("REJECTS arbitrary program IDs with Program<Token> validation", async () => {
  const vaultBefore = await getAccount(provider.connection, secureVaultTokenAccount);

  let attackFailed = false;
  try {
    const txBuilder = secureProgram.methods.transferTokens(new BN(TRANSFER_AMOUNT));

    await (txBuilder as any)
      .accountsPartial({
        authority: authority.publicKey,
        source: secureVaultTokenAccount,
        destination: secureDestinationTokenAccount,
        tokenProgram: attacker.publicKey, // ATTACK: Try to override!
      })
      .signers([authority])
      .rpc();

    assert.fail("Expected transaction to fail");
  } catch (error: unknown) {
    attackFailed = true;
  }

  assert.ok(attackFailed, "Attack should have been rejected");

  const vaultAfter = await getAccount(provider.connection, secureVaultTokenAccount);
  assert.equal(
    Number(vaultBefore.amount),
    Number(vaultAfter.amount),
    "Vault balance should be unchanged (attack rejected)"
  );
});
```

You will see the transaction fail during account deserialization, before the instruction handler even runs. The vault balance remains unchanged.

## Step 5: Understand the vulnerable program (Pinocchio)

In Pinocchio we work at a lower level. The vulnerable version accepts `token_program_info` as the fifth account and performs the CPI without comparing it to `SPL_TOKEN_PROGRAM_ID`:

```rust
#![no_std]

#[cfg(not(feature = "no-entrypoint"))]
#[panic_handler]
fn panic(_info: &core::panic::PanicInfo) -> ! {
    loop {}
}

use pinocchio::{
    entrypoint,
    AccountView,
    Address,
    ProgramResult,
};
use solana_program_error::ProgramError;

pub mod state;
use state::Vault;

const ID: Address = Address::new_from_array([
    0xc9, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
]);

// SPL Token program ID: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
const SPL_TOKEN_PROGRAM_ID: Address = Address::new_from_array([
    0x06, 0xdd, 0xf6, 0xe1, 0xd7, 0x65, 0xa1, 0x93,
    0xd9, 0xcb, 0xe1, 0x46, 0xce, 0xeb, 0x79, 0xac,
    0x1c, 0xb4, 0x85, 0xed, 0x5f, 0x5b, 0x37, 0x91,
    0x3a, 0x8c, 0xf5, 0x85, 0x7e, 0xff, 0x00, 0xa9,
]);

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Address,
    accounts: &[AccountView],
    instruction_data: &[u8],
) -> ProgramResult {
    if program_id != &ID {
        return Err(ProgramError::IncorrectProgramId);
    }

    match instruction_data.first() {
        Some(&0) => initialize(accounts, instruction_data),
        Some(&1) => transfer_tokens(accounts, instruction_data),
        _ => Err(ProgramError::InvalidInstructionData),
    }
}

/// Accounts expected:
/// 0. `[signer]` Authority
/// 1. `[writable]` Vault PDA
/// 2. `[]` Vault token account
/// 3. `[]` System program
fn initialize(accounts: &[AccountView], instruction_data: &[u8]) -> ProgramResult {
    let [authority_info, vault_info, vault_token_account_info, _system_program] = accounts else {
        return Err(ProgramError::NotEnoughAccountKeys);
    };

    if !authority_info.is_signer() {
        return Err(ProgramError::MissingRequiredSignature);
    }

    if !vault_info.owned_by(&ID) {
        return Err(ProgramError::InvalidAccountOwner);
    }

    let bump = *instruction_data.get(1).ok_or(ProgramError::InvalidInstructionData)?;

    let mut vault_data = vault_info.try_borrow_mut()?;

    if vault_data.len() < Vault::LEN {
        return Err(ProgramError::AccountDataTooSmall);
    }

    let vault = Vault {
        authority: authority_info.address().clone(),
        token_account: vault_token_account_info.address().clone(),
        bump,
    };

    vault.to_bytes(&mut vault_data).map_err(|_| ProgramError::AccountDataTooSmall)?;

    Ok(())
}

/// VULNERABLE: token_program at index 4 is never validated.
///
/// Accounts expected:
/// 0. `[signer]` Authority
/// 1. `[]` Vault PDA
/// 2. `[writable]` Source token account
/// 3. `[writable]` Destination token account
/// 4. `[]` Token program (UNCHECKED)
fn transfer_tokens(accounts: &[AccountView], instruction_data: &[u8]) -> ProgramResult {
    let [authority_info, vault_info, source_info, destination_info, token_program_info] = accounts
    else {
        return Err(ProgramError::NotEnoughAccountKeys);
    };

    if !authority_info.is_signer() {
        return Err(ProgramError::MissingRequiredSignature);
    }

    if !vault_info.owned_by(&ID) {
        return Err(ProgramError::InvalidAccountOwner);
    }

    let vault_data = vault_info.try_borrow()?;
    let vault = Vault::from_bytes(&vault_data).map_err(|_| ProgramError::InvalidAccountData)?;

    if authority_info.address() != &vault.authority {
        return Err(ProgramError::InvalidAccountData);
    }

    if source_info.address() != &vault.token_account {
        return Err(ProgramError::InvalidAccountData);
    }

    let amount_bytes: [u8; 8] = instruction_data
        .get(1..9)
        .ok_or(ProgramError::InvalidInstructionData)?
        .try_into()
        .map_err(|_| ProgramError::InvalidInstructionData)?;
    let amount = u64::from_le_bytes(amount_bytes);

    // No validation that token_program_info is the real SPL Token program
    use pinocchio_token::instructions::Transfer;
    Transfer {
        from: source_info,
        to: destination_info,
        authority: authority_info,
        amount,
    }
    .invoke()?;

    Ok(())
}
```

Notice that the `SPL_TOKEN_PROGRAM_ID` constant is defined at the top of the file but never used. The `transfer_tokens` function validates the signer, the vault PDA, the authority, and the source account -- but never checks `token_program_info.address()`. The CPI proceeds to whatever program the caller places at account index 4.

## Step 6: Fix the vulnerability (Pinocchio)

We add a single guard before the CPI:

```rust
#![no_std]

#[cfg(not(feature = "no-entrypoint"))]
#[panic_handler]
fn panic(_info: &core::panic::PanicInfo) -> ! {
    loop {}
}

use pinocchio::{
    entrypoint,
    AccountView,
    Address,
    ProgramResult,
};
use solana_program_error::ProgramError;

pub mod state;
use state::Vault;

const ID: Address = Address::new_from_array([
    0xc9, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
    0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
    0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
    0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
]);

// SPL Token program ID: TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
const SPL_TOKEN_PROGRAM_ID: Address = Address::new_from_array([
    0x06, 0xdd, 0xf6, 0xe1, 0xd7, 0x65, 0xa1, 0x93,
    0xd9, 0xcb, 0xe1, 0x46, 0xce, 0xeb, 0x79, 0xac,
    0x1c, 0xb4, 0x85, 0xed, 0x5f, 0x5b, 0x37, 0x91,
    0x3a, 0x8c, 0xf5, 0x85, 0x7e, 0xff, 0x00, 0xa9,
]);

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Address,
    accounts: &[AccountView],
    instruction_data: &[u8],
) -> ProgramResult {
    if program_id != &ID {
        return Err(ProgramError::IncorrectProgramId);
    }

    match instruction_data.first() {
        Some(&0) => initialize(accounts, instruction_data),
        Some(&1) => transfer_tokens(accounts, instruction_data),
        _ => Err(ProgramError::InvalidInstructionData),
    }
}

/// Accounts expected:
/// 0. `[signer]` Authority
/// 1. `[writable]` Vault PDA
/// 2. `[]` Vault token account
/// 3. `[]` System program
fn initialize(accounts: &[AccountView], instruction_data: &[u8]) -> ProgramResult {
    let [authority_info, vault_info, vault_token_account_info, _system_program] = accounts else {
        return Err(ProgramError::NotEnoughAccountKeys);
    };

    if !authority_info.is_signer() {
        return Err(ProgramError::MissingRequiredSignature);
    }

    if !vault_info.owned_by(&ID) {
        return Err(ProgramError::InvalidAccountOwner);
    }

    let bump = *instruction_data.get(1).ok_or(ProgramError::InvalidInstructionData)?;

    let mut vault_data = vault_info.try_borrow_mut()?;

    if vault_data.len() < Vault::LEN {
        return Err(ProgramError::AccountDataTooSmall);
    }

    let vault = Vault {
        authority: authority_info.address().clone(),
        token_account: vault_token_account_info.address().clone(),
        bump,
    };

    vault.to_bytes(&mut vault_data).map_err(|_| ProgramError::AccountDataTooSmall)?;

    Ok(())
}

/// SECURE: token_program at index 4 is validated before the CPI.
///
/// Accounts expected:
/// 0. `[signer]` Authority
/// 1. `[]` Vault PDA
/// 2. `[writable]` Source token account
/// 3. `[writable]` Destination token account
/// 4. `[]` Token program (VALIDATED)
fn transfer_tokens(accounts: &[AccountView], instruction_data: &[u8]) -> ProgramResult {
    let [authority_info, vault_info, source_info, destination_info, token_program_info] = accounts
    else {
        return Err(ProgramError::NotEnoughAccountKeys);
    };

    if !authority_info.is_signer() {
        return Err(ProgramError::MissingRequiredSignature);
    }

    if !vault_info.owned_by(&ID) {
        return Err(ProgramError::InvalidAccountOwner);
    }

    let vault_data = vault_info.try_borrow()?;
    let vault = Vault::from_bytes(&vault_data).map_err(|_| ProgramError::InvalidAccountData)?;

    if authority_info.address() != &vault.authority {
        return Err(ProgramError::InvalidAccountData);
    }

    if source_info.address() != &vault.token_account {
        return Err(ProgramError::InvalidAccountData);
    }

    let amount_bytes: [u8; 8] = instruction_data
        .get(1..9)
        .ok_or(ProgramError::InvalidInstructionData)?
        .try_into()
        .map_err(|_| ProgramError::InvalidInstructionData)?;
    let amount = u64::from_le_bytes(amount_bytes);

    // FIX: Validate the token program ID before the CPI
    if token_program_info.address() != &SPL_TOKEN_PROGRAM_ID {
        return Err(ProgramError::IncorrectProgramId);
    }

    use pinocchio_token::instructions::Transfer;
    Transfer {
        from: source_info,
        to: destination_info,
        authority: authority_info,
        amount,
    }
    .invoke()?;

    Ok(())
}
```

The fix is three lines inserted before the CPI:

```rust
if token_program_info.address() != &SPL_TOKEN_PROGRAM_ID {
    return Err(ProgramError::IncorrectProgramId);
}
```

If the caller passes any program other than the real SPL Token program, the transaction fails before the CPI ever fires.

## Side-by-side comparison

<Tabs>
  <Tab title="Anchor">
    **Vulnerable** -- accepts any program:
    ```rust
    /// CHECK: This account is NOT checked -- that is the vulnerability.
    pub token_program: UncheckedAccount<'info>,
    ```

    **Secure** -- enforces `spl_token::ID`:
    ```rust
    pub token_program: Program<'info, Token>,
    ```

    Anchor's `Program<'info, T>` type performs the program ID assertion at deserialization time. A single type annotation change eliminates the vulnerability.
  </Tab>

  <Tab title="Pinocchio">
    **Vulnerable** -- no check before CPI:
    ```rust
    use pinocchio_token::instructions::Transfer;
    Transfer {
        from: source_info,
        to: destination_info,
        authority: authority_info,
        amount,
    }
    .invoke()?;
    ```

    **Secure** -- explicit program ID check:
    ```rust
    if token_program_info.address() != &SPL_TOKEN_PROGRAM_ID {
        return Err(ProgramError::IncorrectProgramId);
    }

    use pinocchio_token::instructions::Transfer;
    Transfer {
        from: source_info,
        to: destination_info,
        authority: authority_info,
        amount,
    }
    .invoke()?;
    ```

    Pinocchio provides no built-in type-level guard. We must compare the address against a hardcoded constant before every CPI.
  </Tab>
</Tabs>

## Key takeaways

- **Always validate the program ID before performing a CPI.** An unvalidated CPI target lets attackers run arbitrary code under your program's authority.
- **In Anchor, use `Program<'info, T>` for every CPI target.** Never use `UncheckedAccount` for a program you intend to invoke.
- **In Pinocchio, compare the account address against a hardcoded constant** before every CPI call. There is no type system to do it for you.
- **Validating other accounts is not enough.** The vulnerable program correctly validates the signer, the vault PDA, and the source token account -- none of that matters if the program executing the transfer is malicious.
- **This applies to any CPI target, not just SPL Token.** Oracles, governance programs, bridge programs -- any unvalidated CPI target can be substituted.

## Run it yourself

```bash
# Clone the repository
git clone https://github.com/danielAsaboro/solana_badger.git
cd solana_badger
npm install
```

You will see standard npm output as dependencies install.

```bash
# Run the Anchor tests (vulnerable + secure)
anchor test -- --grep "Arbitrary CPI"
```

You will see two test groups: the vulnerable program accepting an arbitrary program ID (but failing at the CPI level since no real malicious program is deployed), and the secure program rejecting the attack outright during account deserialization.

```bash
# Run the Pinocchio tests
npx jest tests/pinocchio/arbitrary-cpi.pinocchio.test.ts
```

You will see the same pattern: the vulnerable Pinocchio program accepts the substituted program ID, while the secure version returns `IncorrectProgramId` before the CPI fires.
