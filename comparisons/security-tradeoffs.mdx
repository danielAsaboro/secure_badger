---
title: "Security Trade-offs"
description: "Understanding the balance between security, performance, and development speed in Solana programs"
icon: "scale-balanced"
---

# Security Trade-offs

Building Solana programs means choosing between automatic safety and manual control. Anchor wraps every account in validation logic before your instruction even runs; Pinocchio hands you raw bytes and trusts you to check them yourself. This page examines what you actually gain and lose with each approach, grounded in code from this repository.

## What Anchor gives you for free

Anchor's account types encode security constraints directly in the struct definition. The framework validates every constraint before your instruction body executes. Here is what that looks like in practice, taken from the [secure owner-checks implementation](https://github.com/danielAsaboro/solana_badger/tree/main/programs/owner-checks/secure/anchor/src/instructions/update_data.rs):

```rust
#[derive(Accounts)]
pub struct UpdateData<'info> {
    /// Signer check: Anchor verifies this account signed the transaction.
    pub authority: Signer<'info>,

    /// Owner check + discriminator check + deserialization:
    /// Account<'info, ProgramAccount> guarantees the account is owned by
    /// this program, has the correct 8-byte discriminator, and deserializes
    /// to ProgramAccount. All before your instruction runs.
    #[account(mut)]
    pub program_account: Account<'info, ProgramAccount>,
}
```

With these two lines of struct definition, Anchor automatically performs:

| Check | How Anchor enforces it | What happens if it fails |
|-------|----------------------|--------------------------|
| **Signer** | `Signer<'info>` type | `MissingRequiredSignature` error |
| **Owner** | `Account<'info, T>` verifies `account.owner == crate::ID` | `ConstraintOwner` error |
| **Discriminator** | `Account<'info, T>` checks the first 8 bytes | `AccountDiscriminatorMismatch` error |
| **Deserialization** | `Account<'info, T>` deserializes or rejects | `AccountDidNotDeserialize` error |
| **Program ID** | `Program<'info, T>` type | `InvalidProgramId` error |
| **Initialization** | `init` constraint (shown below) | `AccountAlreadyInitialized` error |

For initialization protection, the [secure reinitialization implementation](https://github.com/danielAsaboro/solana_badger/tree/main/programs/reinitialization-attacks/secure/anchor/src/instructions/initialize.rs) shows how a single constraint handles account creation, rent, sizing, and reinitialization prevention:

```rust
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,

    #[account(
        init,           // Checks discriminator is zero, creates account,
        payer = authority, // sets discriminator after init -- one keyword
        space = Vault::LEN // handles rent and sizing automatically
    )]
    pub vault: Account<'info, Vault>,

    pub system_program: Program<'info, System>,
}
```

The instruction body is pure business logic:

```rust
pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
    let vault = &mut ctx.accounts.vault;
    vault.authority = ctx.accounts.authority.key();
    vault.balance = 0;
    Ok(())
}
```

No validation code. No error branches. Anchor handled all of it.

## What Pinocchio requires you to do manually

Here is the equivalent `update_data` function from the [secure Pinocchio owner-checks implementation](https://github.com/danielAsaboro/solana_badger/tree/main/programs/owner-checks/secure/pinocchio/src/lib.rs). Every check that Anchor performs automatically must be written by hand:

```rust
fn update_data(accounts: &[AccountView], instruction_data: &[u8]) -> ProgramResult {
    // 1. Account count check (Anchor does this via struct destructuring)
    let [authority_info, program_account_info] = accounts else {
        return Err(ProgramError::NotEnoughAccountKeys);
    };

    // 2. Signer check (Anchor: Signer<'info> type)
    if !authority_info.is_signer() {
        return Err(ProgramError::MissingRequiredSignature);
    }

    // 3. Owner check (Anchor: Account<'info, T> type)
    if !program_account_info.owned_by(&ID) {
        return Err(ProgramError::InvalidAccountOwner);
    }

    // 4. Instruction data validation (Anchor: function signature types)
    if instruction_data.len() < 9 {
        return Err(ProgramError::InvalidInstructionData);
    }
    let new_data = u64::from_le_bytes(instruction_data[1..9].try_into().unwrap());

    // 5. Borrow and size check (Anchor: automatic deserialization)
    let account_data = program_account_info.try_borrow()?;
    if account_data.len() < ProgramAccount::LEN {
        return Err(ProgramError::AccountDataTooSmall);
    }

    // 6. Initialization check (Anchor: discriminator check)
    if account_data[0] != 1 {
        return Err(ProgramError::UninitializedAccount);
    }

    // 7. Manual deserialization (Anchor: automatic)
    let stored_data = u64::from_le_bytes(account_data[1..9].try_into().unwrap());
    let stored_authority = Address::new_from_array(
        <[u8; 32]>::try_from(&account_data[9..41]).unwrap()
    );

    // --- Business logic starts here ---
    // (update account data)

    Ok(())
}
```

That is seven distinct validation steps before a single line of business logic runs. In the Anchor version, all seven are handled by the two-field struct definition.

The entrypoint itself also requires manual program ID validation and instruction dispatch:

```rust
pub fn process_instruction(
    program_id: &Address,
    accounts: &[AccountView],
    instruction_data: &[u8],
) -> ProgramResult {
    // Program ID check (Anchor: automatic via declare_id!)
    if program_id != &ID {
        return Err(ProgramError::IncorrectProgramId);
    }

    // Instruction dispatch (Anchor: automatic via #[program] macro)
    match instruction_data.first() {
        Some(&0) => initialize(accounts, instruction_data),
        Some(&1) => update_data(accounts, instruction_data),
        _ => Err(ProgramError::InvalidInstructionData),
    }
}
```

## The real cost of "performance"

Let us count the lines in the secure Pinocchio `update_data` function above. The function spans roughly 50 lines. Of those:

| Category | Lines | Percentage |
|----------|-------|------------|
| Validation and error handling | ~30 | 60% |
| Data parsing and deserialization | ~10 | 20% |
| Business logic | ~5 | 10% |
| Comments and whitespace | ~5 | 10% |

The Anchor equivalent puts all validation in the struct (5 lines) and business logic in the function (8 lines). The total is 13 lines for the same security guarantees.

Pinocchio's compute unit savings do not come from eliminating validation -- they come from giving you the option to skip it. When you write all the same checks by hand (as you must for a secure program), the performance gap narrows substantially. What remains is the overhead of Anchor's deserialization and IDL generation, not the cost of security itself.

<Warning>
If your Pinocchio program uses fewer compute units than the equivalent Anchor program **and** you wrote fewer validation checks, you did not gain performance -- you lost security.
</Warning>

## Security maturity levels

### Level 1: Vulnerable

These patterns appear in the vulnerable implementations throughout this repository. They represent code that will be exploited in production.

From the [vulnerable signer-checks Anchor implementation](https://github.com/danielAsaboro/solana_badger/tree/main/programs/signer-checks/vulnerable/anchor/src/instructions/update_owner.rs):

```rust
#[derive(Accounts)]
pub struct UpdateOwnership<'info> {
    // UncheckedAccount instead of Signer -- anyone can pass any pubkey
    /// CHECK: INTENTIONALLY VULNERABLE
    pub owner: UncheckedAccount<'info>,

    #[account(
        mut,
        has_one = owner,  // Checks data matches, NOT that owner signed
        seeds = [b"program-account", owner.key().as_ref()],
        bump
    )]
    pub program_account: Account<'info, ProgramAccount>,

    /// CHECK: This is the new owner being set
    pub new_owner: UncheckedAccount<'info>,
}
```

The `has_one` constraint verifies that `program_account.owner == owner.key()`, but it does **not** verify that `owner` signed the transaction. An attacker reads the owner's pubkey from on-chain data, passes it as the `owner` account without a signature, and transfers ownership to themselves.

From the [vulnerable signer-checks Pinocchio implementation](https://github.com/danielAsaboro/solana_badger/tree/main/programs/signer-checks/vulnerable/pinocchio/src/lib.rs), the same mistake in raw form:

```rust
// Data validation passes (stored key == provided key)
if stored_owner != *owner_info.address() {
    return Err(ProgramError::InvalidAccountData);
}

// MISSING: if !owner_info.is_signer() { return Err(...); }

// Attacker changes ownership without the real owner's signature
data[1..33].copy_from_slice(new_owner_info.address().as_ref());
```

### Level 2: Basic security

The minimum fix addresses the specific vulnerability. From the [secure signer-checks Anchor implementation](https://github.com/danielAsaboro/solana_badger/tree/main/programs/signer-checks/secure/anchor/src/instructions/update_owner.rs):

```rust
#[derive(Accounts)]
pub struct UpdateOwnership<'info> {
    pub owner: Signer<'info>,  // One type change fixes the vulnerability

    #[account(
        mut,
        has_one = owner,
        seeds = [b"program-account", owner.key().as_ref()],
        bump
    )]
    pub program_account: Account<'info, ProgramAccount>,

    /// CHECK: This is the new owner being set
    pub new_owner: UncheckedAccount<'info>,
}
```

Changing `UncheckedAccount` to `Signer` is a single-word fix in Anchor. In Pinocchio, the equivalent fix is adding `if !owner_info.is_signer() { return Err(ProgramError::MissingRequiredSignature); }` -- easy to write, but also easy to forget.

### Level 3: Production ready

Anchor's constraint system lets you layer business logic validation on top of the automatic checks. From the [secure reinitialization implementation](https://github.com/danielAsaboro/solana_badger/tree/main/programs/reinitialization-attacks/secure/anchor/src/instructions/initialize.rs):

```rust
#[account(
    init,                    // Prevents reinitialization
    payer = authority,       // Handles rent
    space = Vault::LEN       // Correct sizing
)]
pub vault: Account<'info, Vault>,
```

In production, you combine multiple constraints:

```rust
#[account(
    mut,
    has_one = authority,
    constraint = vault.amount >= min_amount @ ErrorCode::InsufficientFunds,
)]
pub vault: Account<'info, Vault>,
```

Each `constraint` is a compile-time guarantee that the check will run before the instruction body.

### Level 4: Battle-tested

For high-value protocols, add runtime checks inside the instruction body on top of the declarative constraints:

```rust
#[account(
    mut,
    has_one = authority,
    constraint = vault.is_initialized @ ErrorCode::NotInitialized,
    constraint = vault.amount >= min_amount @ ErrorCode::InsufficientFunds,
    constraint = !vault.is_frozen @ ErrorCode::VaultFrozen,
)]
pub vault: Account<'info, Vault>,

// Additional runtime checks in instruction body
pub fn secure_operation(ctx: Context<Operation>, amount: u64) -> Result<()> {
    require!(
        ctx.accounts.vault.last_operation + MIN_DELAY < Clock::get()?.unix_timestamp,
        ErrorCode::RateLimited
    );
    // Multiple defense layers
    Ok(())
}
```

This combines declarative constraints (checked before the instruction runs) with imperative checks (checked inside the instruction), giving auditors two independent layers to verify.

## Decision framework

| Protocol Type | Recommended Framework | Reason |
|---------------|----------------------|--------|
| **DeFi Lending** | Anchor | Security critical, complex state |
| **DEX (AMM)** | Anchor | Moderate complexity, high value |
| **DEX (Orderbook)** | Hybrid (mostly Anchor) | Hot path in Pinocchio, rest Anchor |
| **Staking** | Anchor | Simple logic, security matters |
| **NFT Marketplace** | Anchor | Fast development, moderate complexity |
| **HFT Engine** | Pinocchio | Performance critical, expert team |
| **Token Vesting** | Anchor | Time-based logic, security critical |
| **DAO Governance** | Anchor | Complex authorization, high risk |

## Security checklist

### Anchor

- [ ] Use `Account<'info, T>` for all typed accounts (not `UncheckedAccount`)
- [ ] Use `Signer<'info>` for authority accounts
- [ ] Use `Program<'info, T>` for CPI targets
- [ ] Use `init` constraint for initialization (prevents reinitialization)
- [ ] Add `has_one` constraints for ownership validation
- [ ] Include user pubkey in PDA seeds for user-specific accounts
- [ ] Write tests demonstrating exploits are prevented
- [ ] Avoid `init_if_needed` unless genuinely needed
- [ ] Add custom `constraint` validations for business logic
- [ ] Document all `UncheckedAccount` usage with `/// CHECK:` comments

### Pinocchio

- [ ] Check `is_signer()` for all authority accounts
- [ ] Check `owned_by(&crate::ID)` for all program accounts
- [ ] Validate discriminator / initialization flag before deserialization
- [ ] Validate program ID before all CPIs
- [ ] Check initialization status before writing account data
- [ ] Include user pubkey in all user-specific PDA derivations
- [ ] Validate account data size before reading fields
- [ ] Validate instruction data length before parsing
- [ ] Write comprehensive tests for each validation check
- [ ] Security audit by experienced Solana auditors

## Final recommendation

For most projects, use Anchor. Its "overhead" is the cost of mandatory security checks that you would need to write by hand in Pinocchio anyway. The code in this repository demonstrates this directly: the secure Pinocchio implementations contain the same validation logic that Anchor generates automatically, but spread across dozens of lines that each represent an opportunity to introduce a bug.

Optimize to Pinocchio only after profiling shows a genuine compute budget constraint, and only for the specific hot paths that need it. A program that is 10% slower but provably secure is worth more than a program that is 10% faster and missing a signer check.
